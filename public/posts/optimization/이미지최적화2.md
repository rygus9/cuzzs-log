---
title: Cuzz's Log 이미지 최적화 2 (원론적인 이야기)
tags: ["optimization"]
uploadDate: 2022년 9월 15일
description: 멀고도 험난한 이미지 최적화의 길, 두 번째
---

이번 블로그에서는 이미지 최적화에 대한 기본적이고 원론적인 이야기를 할까 한다. 원래는 이미지 최적화 1에서 다루었던 것처럼 next/Image로 끝내려고 하였으나 vercel에서 제공하는 이미지 최적화 기법이 나와 좀 맞지 않았다. 공식 문서 보면서 그냥그냥 하려 했지만 잘 안돼서 이미지 최적화의 원론적이고 기초적인 부분부터 짚고 넘어가려고 한다. 사실 뭐 인트로가 거창하긴 한데 별 이야기 없다.

> 개인적인 생각이 넘쳐나는 글입니다. 워낙 뭔가를 공부하면 자기 말로 바꿔 이해하는 걸 좋아하기에 좀 잘못 바꾼 내용이 있을 수 있습니다. 그리고 서버 쪽은 정말 제 머릿속 내용이라 헤헷... 하루빨리 댓글 기능을 추가해서 피드백을 받아야겠네요.

### 이미지 최적화 큰 그림

이미지 최적화는 크게 두 트랙으로 보면 좋을 듯싶다.

1. 이미지 자체의 크기 줄이기, CDN 활용 (벡엔드)
2. 브라우저에 최적화와 관련된 문법 적용하기 (프론트엔드)

참고로 Next/image 태그는 2번 같은 경우 그냥 해주지만 1번 같은 경우는 vercel을 써야 해준다. vercel을 안쓴다면 반쪽짜리 기능이라고 봐도 무방하다.

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization2_1.png" alt="image_optimization2_1" style="zoom:67%;" />

위에 그림은 지금 내가 설명할 내용을 총정리해둔 그림이다. 정말 간단하게 서버는 이미지가 들어온 시점이든 이미지가 나가는 시점이든 이미지를 주기 직전에 특정 이미지의 용량을 최대한 줄여서 보내고 프론트엔드는 이를 잘 받아서 쓰면 이미지 최적화 끝이다. 사실 이미지 최적화는 서버에서 이미지 용량을 얼마나 줄여주는지가 가장 중요하다. 프론트는 이걸 잘 받아쓸 뿐이다.

서버 측에서 이미지 최적화를 진행하는 시점은 크게 두 가지가 있다. 이미지가 들어올 때 최적화하는 방식과 해당 이미지를 호출할 때 최적화하는 방식이다. 밑에 표로 정리해두었고 이 두 가지 경우는 서버에서 처리하는 방식이고 여기에 프론트엔드에서 사용자가 이미지를 올릴 때 처리하는 방식도 있다.

|                |       이미지가 들어올 때 최적화       |    해당 이미지를 가져올 때 최적화     |
| :------------: | :-----------------------------------: | :-----------------------------------: |
| Cuzz's Log에선 |    내가 빌드할 때 이미지를 최적화     | 해당 블로그로 요청이 들어올 때 최적화 |
|   응답 시간    | 이미 최적화된 이미지를 주면 되서 빠름 |   이미지를 최적화하는 과정이 필요함   |
|  업로드 시간   |    업로드시 최적화가 진행되어 느림    |      원본만 박아두면 되니 빠름.       |
|   저장 공간    | 최적화된 이미지를 저장할 공간이 필요  |          원본막 저장하면 됌           |

> 사용자들이 자주 이미지를 올리고 자주 방문하는 사이트는 CDN을 믿고 맨 처음 캐시 미스가 날 때에만 최적화를 진행하는 것도 나쁘지 않다고 생각한다. 요새 lambda@edge도 그렇고 vercel도 그렇고 요청 시에 처리하는 로직을 제공하는 걸 보아 그리 나쁜 선택지는 아닌 듯싶다. 그러나 내 경우에 SSG로 다른 건 로딩 시간이 거의 없는데 이미지만 로딩 시간을 잡아먹는 게 너무 기분 나쁘다.
>
> 참고로 Front 딴에서 사용자가 파일을 업로드할 때 처리하는 방식은 이미지를 처리하는데 드는 서버 비용을 아낄 수 있다는 장점이 있으나 쓸데없이 통신을 더해야 한다는 단점이 있다. 요새는 다 벡엔드에서 처리하는 추세다. 내가 인턴을 했던 곳도 벡엔드에서 이미지를 최적화해주었다.

### 서버 측 이미지 최적화

사용자가 올린 파일을 그냥 쓰면 네트워크 트래픽 터진다. 내가 블로그에 사진 올릴 때에도 아무 생각 없이 1MB, 2MB 짜리 사진을 올리는데 사용자들은 오죽할까 싶다. 특히 모바일로 찍은 사진은 픽셀 값이 어마어마하기 때문에 이걸 그냥 쓰면 진짜 서비스가 느려진다. 용량을 줄이는 방법으로는 1.사진 사이즈 줄이기 2. 품질 낮추기 3. 압축률 높은 이미지 포맷 사용하기 정도가 있다.

#### 1. 이미지 사이즈 조절

사이즈가 진짜 용량 많이 잡아먹는다. 물론 사진 안에 들어가는 픽셀 값이 크면 고해상도 이미지를 지원하겠지만, 솔직히 쓸데없다. 이미지 크기를 줄이는 것만으로 사진 용량을 어마어마하게 줄일 수 있다.

![image_optimization2_2](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization2_2.png)

간단하게 Cuzz's Log의 마스코트인 귀여운 고양이 사진의 사이즈를 줄여보았다. 크기가 351KB에서 130KB로 1/3 가까이 줄어든 걸 볼 수 있다. 픽셀 값이 엄청나게 많은 고해상도 사진이면 사진일수록 리사이징해서 용량 줄이는 맛이 있다.

보통 프론트엔드 디바이스에 따라 다른 사이즈의 이미지를 제공하기 위해 여러 사이즈 버전으로 리사이징 시켜둔다. 나도 아마 중간 크기와 데스크탑 크기 두 가지로 리사이징 시키지 않을까 싶다.

#### 2. Format 변경

포맷 변경만으로 사진의 용량을 줄일 수 있다. 포맷마다 이미지를 인코딩하고 디코딩하는 방식이 다른데 어떤 포맷이냐에 따라 이미지의 품질은 유지하면서 이미지를 효율적으로 압축할 수 있다. 주목받는 포맷은 크게 두 가지로 webp, avif가 있는데 성능은 avif 더 뛰어나지만, 브라우저 지원은 webp가 더 뛰어나다. [canIuse](https://caniuse.com) 에서 보면 webp는 97%, avif는 71% 정도 지원한다.

> 이미지 첨부하기 모호해서 글로 올린다. 간단히 포맷 컨버팅하는 사이트에서 webp로 바꾸었으며 130KB에서 60KB로 압축되었다.

#### 3. CDN 설정

벡서버에서 직접 이미지를 주는 방식은 거리가 멀어지면 멀어질수록 느려진다. [cloudping 사이트](https://cloudping.info/)에서 보는 것처럼 물리적인 거리가 통신 시간에 영향을 줌을 알 수 있다. 그리고 벡엔드 서버에 모든 요청이 처리되면 벡엔드 서버에 가해지는 부하가 커져 느려진다. 이를 해결하고자 전 세계에 서버가 필요없는 정적 파일을 제공하는 서버를 두고 해당 정적 파일에 대한 요청이 들어왔을 때 벡엔드 서버로 가지 않고 전 세계 퍼져있는 서버 중 가장 가까운 서버에서 가져오는 기술이 생겨났다. 이게 CDN이다.

- 벡엔드에 가기 전에 CDN에 있는 자료면 중간 서버서 이미지를 가져오고 CDN에 없으면 그 때 벡엔드 서버와 통신한다. 캐시 힛과 캐시 미스와 똑같은 메커니즘이다. 요새 CDN에서 최적화가 안 된 이미지를 최적화해주는 기능도 있다고 하니 어지간하면 쓰자.

- vercel을 쓰면 알아서 CDN을 적용해준다. AWS 사용자라면 CloudFront를 이용해 CDN을 설정할 수 있다. AWS Amplify를 쓰면 CloudFront 설정 없이도 CDN을 사용할 수 있다.

### 클라이언트 측 이미지 최적화

#### 1. 서버에서 지원하는 이미지를 잘 가져오기

보통 서버에서는 하나의 이미지를 여러 사이즈의 이미지들로 변환해서 내보내 준다. 이렇게 하는 이유는 다양한 화면 크기를 지원하는 웹 환경에서 화면 크기에 맞게 적절한 이미지를 선택하는 선택지를 제공하기 위해서다.

서버에서 이렇게 여러 이미지를 제공해도 브라우저 딴에서 제대로 활용하지 못하면 말짱 도루묵이다. 그래서 브라우저에 자신이 지원하는 화면 크기에 맞는 이미지를 불러오라고 지시를 해두어야 한다. 이때 쓰는 속성이 바로 srcset과 sizes이다. 우선 srcset부터 보도록 하자.

```html
<img
  alt="alt는 기본입니다!"
  srcset="이미지_경로 뷰포트_크기(픽셀)w,
          /image380.webp 380w, 
          /image560.webp 560w, 
          /image1080.webp 1080w"
  src="/imagedefault.webp"
/>
```

srcset안에는 저렇게 이미지 경로와 뷰포트 크기가 쉼표 단위로 나누어져 있다. 브라우저가 여러 뷰포트 크기를 보고 자신이 필요한 이미지를 선택해 가져온다. 나는 그저 이 크기에 이 이미지가 필요하다는 것만 알려주고 이를 기반으로 브라우저가 선택한다.

> 참고로 브라우저 크기를 조절하고 리로드해 다른 이미지를 가져오는지 테스트하려 했으나 같은 이미지만 가져온다. 즉 여기서 뷰포트 크기는 브라우저가 정한 디폴트로 꽉 찬 화면 크기임을 알 수 있다.

```html
<img
  alt="alt는 기본입니다!"
  srcset="이미지_경로 뷰포트_크기w,
          /image380.webp 380w,
          /image560.webp 560w,
          /image1080.webp 1080w"
  sizes="(미디어_쿼리) 나오는_사진_사이즈
         (max-width: 1080px) 1080px,
         (max-width: 560px) 560px,
         (max-width: 380px) 380px"
  src="/imagedefault.webp"
/>
```

만약 브라우저가 srcset 속성을 보고 사진을 선택할 때 sizes 속성이 있으면 sizes 속성에 정의된 미디어 쿼리에 자신의 뷰포트 크기를 대입시켜 나온 값을 기반으로 이미지를 선택한다. 해당 값을 가장 잘 표현하는 크기를 가진 사진(보통 조금 더 큰 사이즈로 srcset에 정의된 사진)을 가져오며 width 속성이 없을 시에는 해당 값이 곧 img 태그의 넓이를 결정한다.

> 넓이를 결정한다는 말로 한 이유는 sizes의 380px라는 명시가 브라우저의 img 태그의 넓이가 380px임을 보증하지 않기 때문이다. img 태그의 정확한 넓이를 지정하고 싶으면 width 속성을 써야 한다. 그리고 width 속성을 쓴다고 sizes가 아무 역할도 안하는 건 아니다. sizes는 미디어 쿼리에 정의된 크기에 맞게 srcset에 불러올 사진을 결정한다.

- 브라우저가 인식하는 뷰포트 크기 = ( sizes에서 미디어 쿼리 통과 ) => 가져와야 할 사진 크기 = ( srcset의 w 디스크립터 확인) => 이미지 url 선택 = ( width의 값, 없으면 sizes의 값, 없으면 디폴트 사진 크기) => 이미지 렌더링
- sizes를 쓰더라도 브라우저가 인식하는 뷰포트 크기로부터 선택이 시작되기에 브라우저의 선택이다. 만약 브라우저의 선택이 싫다면 css의 미디어 쿼리 속성을 이용해 화면 크기별로 불러올 이미지를 우리가 직접 선택할 수 있다.

#### 2. 이미지 로딩 과정 개선

```html
<img decoding="async" loading="lazy" fetchPriority="low" src="경로" alt="alt는 기본!" />
```

- **decoding** : 이미지를 디코딩하는 과정을 어떻게 진행할지 결정하는 속성이다.

  다른 콘텐츠와 함께 표시하기 위해 동기적으로 디코딩하는 sync, 다른 콘텐츠의 표시 지연을 피하고자 비동기적으로 디코딩하는 async, 브라우저에게 맡기는 auto가 있다. 나는 다른 콘텐츠의 표시 지연을 피하려고 async를 썼다. 참고로 Icanuse를 볼 때 지원하는 브라우저가 많진 않다.

- **loading** : 브라우저가 이미지를 불러올 때 사용할 방식을 지정하는 속성이다.

  무지성으로 이미지를 가져오는 eager, 이미지가 뷰포트의 일정 거리 안에 들어와서 브라우저가 로딩이 필요하다 싶을 때 이미지를 가져오는 lazy가 있다. 지원하는 브라우저도 많고 성능 향상도 꽤 되기에 특수한 경우 아니면 lazy 사용을 추천한다.

- **fetchPriority** : fetchPriority속성은 high 값과 low 값으로 브라우저에게 이 이미지가 중요한지 알려주는 역할을 한다. 브라우저는 이걸 보고 어떤 이미지를 먼저 요청할지 정할 수 있다. 아직 실험 기능이고 지원하는 브라우저도 별로 없지만 꽤 유용할 듯싶으니 빨리 대중화되었으면 한다.

### 마무리

이것저것 얘기를 많이 했는데 요약하면 다음과 같다.

1. 서버는 이미지의 용량을 줄이고 다양한 화면에 맞는 이미지 사이즈를 여러 개 준비해 프론트에 뿌려준다. 이때 CDN을 사용하면 더 빠르게 보내줄 수 있다.
2. 브라우저에서는 서버가 줄 수 있는 다양한 사이즈의 이미지 중 적절한 사이즈의 이미지를 가져와야 한다. 그리고 lazy loading, async decoding 등을 통해 이미지 로딩 과정을 개선하면 좋다.

다음 장에서는 지금까지 배운 지식으로 이미지 최적화를 진행할까 한다. 큰 그림은 다음과 같다.

1. 서버의 입장에서 나는 public 폴더 내의 이미지만 최적화시키면 된다. 그래서 cloudinary 같은 이미지 최적화 서비스는 좀 과하다. 그냥 빌드 시점에 최적화된 이미지들을 만들어두면 될 듯싶다. 원래는 webpack에 합치고 싶었는데 포맷 변경은 가능하지만 리사이징이 힘들어서 그냥 git action 같은 거에 최적화하는 로직을 걸어버릴까 한다.
2. Next/Image 태그는 vercel에 내장된 이미지 최적화 기능을 이용한 경우나 cloudinary 같은 nextjs 에서 미리 대비한 다른 이미지 최적화 서버를 이용한 경우에 코드를 획기적으로 줄여준다. 하지만 이게 아니라면 솔직히 그냥 직접 최적화하는 게 낫다.

역시 Next/Image라는 마법 안에서 안주하기보다는 직접 발품 뛰면서 정보 찾아다니는 게 더 유익했던 것 같다.

##### 참고 자료

MDN: [https://developer.mozilla.org/ko/docs/Web/HTML/Element/img#attr-importance](https://developer.mozilla.org/ko/docs/Web/HTML/Element/img#attr-importance)
HEROPY TECK : [https://heropy.blog/2019/06/16/html-img-srcset-and-sizes/](https://heropy.blog/2019/06/16/html-img-srcset-and-sizes/)
