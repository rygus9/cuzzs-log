---
title: Cuzz's Log 이미지 최적화 3 (with NextJS)
tags: ["optimization"]
uploadDate: 2022년 9월 16일
description: 이미지 최적화를 진행해보자
---

이전에 다루었던 이미지 최적화와 관련된 내용을 바탕으로 이 블로그에 이미지 최적화를 적용해보도록 하자. 크게 보면 vercel로 푸시하기 전에 미리 최적화된 이미지를 준비해두었고 Next/image를 쓰지 않고 직접 img 태그를 작성하였다. 나도 이렇게까지 많이 바뀔 줄은 몰랐다. 글을 쓸 때 왜 이런 선택을 했는지와 어떻게 구현했는지를 위주로 이야기해보도록 하겠다.

### 최적화된 이미지 준비하기

기존 vercel에서 처리하는 방식은 요청이 올 때 이미지 최적화를 진행하기 때문에 이미지를 최적화하는 시간만큼 응답에 지연이 걸리게 된다. 물론 CDN을 이용하기 때문에 매 요청마다 최적화를 진행하지 않지만 그래도 CDN에서 캐시 미스가 날 때에는 응답에 지연이 걸리게 된다. 내 블로그에서 사진은 나 혼자 올리니 그냥 미리 빌드 과정이나 그 이전에 최적화를 해두는 게 낫겠다고 판단하였다.

* 이미지의 용량을 줄이는 방법으로는 1. 퀄리티를 낮추기 2.사이즈를 최대한 줄이기 3. 효율적인 포맷으로 변환하기가 있다.

* 빌드 과정에 하는 방식과 빌드 이전에 내가 수동으로 하는 방식을 생각하였다. 

  빌드 과정 중에 하는 방법을 찾아보았는데 포맷 변경 같은 경우에는 웹팩의 로더로 지원해주지만 하나의 이미지를 여러 사이즈로 리사이징해주는 툴은 찾지 못하였다. 내 역량 한계로 찾다 포기하였다.

  그래서 그냥 이미지를 리사이징해주는 코드를 작성하고 이를 node로 실행하는 방식으로 가져갔다. 추후 git hook 을 이용해 commit 하기 전에 무조건 실행시키도록 자동화할 예정이다.

  

#### 코드 작성하기

1. Public 폴더 내 블로그에 들어갈 모든 이미지를 가져와야 한다. 나는 stack을 활용한 DFS 방식을 사용하여 public 폴더 내 확장자가 .png인 파일의 경로를 가져왔다. 코드가 더럽긴 하지만 지금은 이게 최선이었다. 추후 리펙토링을 진행할 예정이다.
   ```js
   const sharp = require("sharp");
   const path = require("path");
   const dirPath = path.dirname(__filename);
   const fs = require("fs");
   
   const getImagePaths = () => {
     const postsRoot = path.resolve(dirPath, "../public/posts");
     const images = [];
   
     const stack = [];
     const basefiles = fs.readdirSync(postsRoot, { withFileTypes: true });
   
     stack.push(
       ...basefiles.reverse().map((elem) => ({ path: postsRoot, fileName: elem.name, isDirectory: elem.isDirectory() }))
     );
   
     while (stack.length !== 0) {
       const now = stack.pop();
       if (now?.isDirectory) {
         const subfiles = fs.readdirSync(`${now.path}/${now.fileName}`, { withFileTypes: true });
         stack.push(
           ...subfiles.reverse().map((elem) => ({
             path: `${now.path}/${now.fileName}`,
             fileName: elem.name,
             isDirectory: elem.isDirectory(),
           }))
         );
       } else {
         if (now?.fileName.endsWith(".png")) images.push(`${now?.path}/${now?.fileName}`);
       }
     }
     return images;
   };
   ```

2. 이미지를 리사이징하는 함수를 정의한다. 해당 함수는 sharp 라이브러리를 사용하며 sharp 라이브러리의 기능을 통해 입력받은 경로의 이미지를 최적화한다.

   ```js
   const optimizeImage = (path, width, quality) =>
   Image = (path, width, quality) =>
     sharp(path)
       .resize({ fit: sharp.fit.contain, width })
       .webp({ quality })
       .toFile(pathChange(path, width, "webp"))
       .then(() => console.log(path + " is done"))
       .catch((err) => console.error("에러 발생 : ", err));
   ```

3. 여기서 pathChange라는 함수를 썼는데 원본 이미지를 가져오는 경로와 최적화된 이미지를 저장하는 경로는 다르기 때문에 원본 경로에서 이미지를 출력할 경로로 바꿔주는 함수를 작성하였다. 원본이 image/test.png라면 출력되는 경로는 image/optImage/testw500.webp다.
   ```js
   const pathChange = (filepath, width, ext) => {
     let fileParseObj = path.parse(filepath);
     let name = fileParseObj.name;
     let dir = fileParseObj.dir;
   
     dir = path.resolve(dir, "optImage");
     !fs.existsSync(dir) && fs.mkdirSync(dir);
   
     return dir + "/" + name + "w" + width + "." + ext;
   };
   ```

4. 마지막으로 이미지 경로를 리턴하는 함수와 이미지를 최적화해주는 함수를 사용하여 최적화된 이미지를 만들어낸다. 추후 브라우저에서 화면 크기에 맞게 적절한 사이즈의 이미지를 지원하기 위해서 여러 사이즈의 이미지를 미리 만들어두었다.

   ```js
   const images = getImagePaths();
   
   for (const elem of images) {
     optimizeImage(elem, 1440, 95);
     optimizeImage(elem, 800, 95);
     optimizeImage(elem, 520, 95);
   }
   ```

* 이로써 최적화된 이미지를 만들어내는 과정은 끝이다. 위 코드를 하나의 js 파일에 몰아두고 node 명령어로 실행시키면 된다.
  ```json
  {
    //...
    "scripts": {
      "optImage" : "node ./inprebuild/imageOpt.js"
    }
  }
  ```

  ```bash
  npm run optImage
  ```

  <img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization3_1.png" alt="image_optimization3_1" width="1220" height="610" />

> 이로써 하나의 이미지를 여러 사이즈의 최적화된 이미지로 표현해보았다. 빌드 전이나 실행 전에 일일이 코드를 실행해야 하는 단점이 있지만 내가 원하는 시점에 이미지를 최적화할 수 있다는 장점이 있다. 정 불편하면 script의 dev나 build의 명령어를 optImage를 먼저 실행시킨 후에 실행하는 방법이 있다. 물론 이게 최선의 방법이라고 생각하지 않는다. 아무래도 웹팩에서 번들링하는 도중에 하는게 가장 깔끔할 듯 싶으나 좀 힘들다. 이거에 쏟는 시간 대비 얻는 게 적다는 판단이 들기도 하였고 애초에 요즘 시간도 많지 않다... 나중에 시간 되면 이미지 최적화와 관련된 로더를 만들어 봐야겠다.



### 프론트엔드에서 이미지 사용하기

위의 과정을 통해 최적화된 이미지를 준비했으니 이를 잘 이용할 수 있도록 img 태그를 작성해보도록 하자. 예전에 썼던 이미지 최적화 2편에서 배운 속성들을 잘 활용할 예정이다.

* 우선 Next/Image를 사용하길 포기했는데 srcset을 내가 직접 정의하게 해주는 인터페이스가 없기 때문이다. Next/Image의 loader 기능은 리턴 타입이 string이고 바로 src 속성에 들어간다. 나름 공식 문서를 쭉 읽고 내린 결론이 srcset을 직접 다룰 수 있는 속성이 없다는 것이었다.(나란 놈은 빼먹는 거 일쑤라 틀릴 수 있습니다.) 그래서 그냥 img 태그 쓰기로 했다.

#### 코드 작성하기

1. 기존에 있던 imgRenderer에서 Next/Image로 리턴하는 함수를 img로 리턴하게 바꾸면 된다. 쉽다.
   ```react
   const postfixs = ["520", "800", "1440"];
   function imgRenderer(props: any) {
     let originSrc = props.src;
     let srcSplit = originSrc.split("/");
     const filename = srcSplit.slice(-1)[0];
     const name = filename.split(".")[0];
     const ext = "webp";
     const dirname = srcSplit.slice(0, -1).join("/") + "/optImage/";
     let srcset = "";
   
     for (const postfix of postfixs) {
       srcset += dirname + name + "w" + postfix + "." + ext + " " + postfix + "w" + ",";
     }
     const src = dirname + name + "w1440." + ext;
     return <img decoding="async" loading="lazy" alt="blog images" srcSet={srcset} src={src}></img>;
   }
   ```

   뭔가 복잡한 코드들이 있는데 그냥 markdown에 있던 원본 주소를 srcset에 들어갈 문자열로 바꾸기 위한 노력으로 보면 된다. 위의 이미지 최적화할 때 .png 파일의 경로 찾기 로직 다음으로 리펙토링 대상 2 순위다. 중요한 건 img 태그에 decoding과 loading, srcSet, alt, src 속성을 정의해 브라우저에서 할 수 있는 최적화를 했다는 점이다.



### 결론 

이 글을 쓰는 시점은 아직 최적화를 진행한 코드가 배포에 반영되지 않은 시점이다. 반영한 이후 lighthouse에서 점수를 다시 확인한 후 이 부분을 마저 작성할 예정이다. 생각보다 힘들게 구현했지만 하니깐 기분은 좋다. 역시 나는 성능 향상시키는게 가장 기분 좋다. 

* 09-17일 추가

> 이만하면 됐다 하고 끝내려고 했으나 이미지가 로딩된 이후 공간을 차지하는 현상으로 인해 현재 방식처럼 초기 넓이와 높이를 지정하지 않으면 필연적으로 리플로우가 발생한다. 사용자 입장에서도 거의 단락과 단락 사이에 이미지가 팡하고 나타나기 때문에 사용성도 엉망이다. 귀찮지만 이미지 로딩 과정을 처리해야겠다.
