---
title: Cuzz's Log 이미지 최적화 1 (with NextJS)
tags: ["optimization"]
uploadDate: 2022년 9월 11일
description: 멀고도 험난한 이미지 최적화의 길
---

블로그를 만든 기쁨도 잠시 처음 만든 블로그여서 그런지 몰라도 허점투성이였다. 블로그 개발 후기에서는 사진을 이용하지 않았기 때문에 이미지에 관해서 별생각이 없었으나 학교 프로젝트 후기에 들어간 두 이미지가 나를 이미지 최적화의 길로 이끌었다. 이 포스트는 이미지 최적화를 진행하면서 내가 진행했던 삽질을 기록해보고자 한다. 아마 3편까지 나올 듯싶다. 아직 내가 원하는 대로 해결하지 못해서 언제 끝날지 모른다.

### LightHouse

구글에서 개발한 웹 페이지 성능 검사 도구다. 여러 가지 성능 지표들을 정말 간단하게 확인할 수 있다. 웹 페이지 자체에 대한 검사이기 러프한 감이 없잖아 있지만, 페이지 성능을 측정할 때 가장 빠르고 직관적이니 사용해볼 것을 추천한다. 사용 방법은 아래와 같다.

1. 개발자 도구의 LightHouse 탭을 통해서 확인할 수 있다.
2. 크롬 확장 플러그인으로 LightHouse를 설치한 이후 사용할 수 있다.
3. [web.dev](web.dev)에서 url를 입력하여 실행시킬 수 있다. 이 페이지가 LightHouse에 관련된 페이지이니 자세히 알고 싶으면 이 페이지에서 공부해보도록 하자.

나는 처음에 실행시켰을 때 성능상 걸릴 부분이 거의 없을 것으로 생각했다. SSG이기에 서버가 이미 완성된 HTML 뿌려주는데 이것보다 성능이 안 좋을 수 있을까 했다. 하지만 이미지를 무시한 대가는 꽤 컷다.



### 내 블로그 성능 평가

![image_optimization1_1](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization1_1.png)

블로그 대부분의 리소스를 차지하는 게 이미지이고 이 때문에 이미지를 다루는 대부분 서비스는 이미지 최적화에 최선을 다한다. 나는 정말 안일하게 그냥 이미지를 그냥 넣었고 그 결과 이렇게 적나라한 결과를 받게 되었다. 이미지가 2개 뿐이기도 하고 이미지가 좀 밑에 있기에 여태 문제가 있는 줄 몰랐지만, 만약 이미지가 화면 상단에 나오고 이미지의 개수가 많아진다면 어찌 될지 모른다. 그러니 이 기회에 이미지 최적화를 진행해볼까 한다.



### 이미지 최적화 시작!

현재 블로그는 markdown에서 이미지 태그로 변환 이후 url만 손봐주고 아무것도 안 한다. 나는 여기에 next/image 태그를 렌더링할 생각이다. 방법은 다음과 같다.

1. [React-markdown](https://github.com/remarkjs/react-markdown)을 보면 react-markdown은 markdown => remark 플러그인 => rehype 플러그인 => components 에 정의된 렌더러 함수들 => 리액트 요소들로 변환이 진행된다. 나는 components 속성에 img 관련 렌더러 함수를 정의한다.

   ```react
   <section className={cls("prose prose-lg prose-invert m-auto max-w-none")}>
     <!-- img: imgRenderer 코드 추가 -->
     <ReactMarkdown
       components={{ a: LinkRenderer, pre: preRenderer, img: imgRenderer }}
       remarkPlugins={[remarkGfm]}
       rehypePlugins={[rehypeRaw, [urls, removeBaseUrl]]}
       className="w-full"
     >
       {children}
     </ReactMarkdown>
   </section>
   ```

2. imgRenderer 함수에는 이미지 최적화 관련 코드를 넣어준다. 간단하게 nextJS에서 제공하는 image 관련 라이브러리를 사용했다.
   ```react
   import Image from "next/future/image";
   
   function imgRenderer(props: any) {
     return <Image src={props.src} alt="blog images" sizes="100vw" quality={80} loading="lazy">	</Image>;
   }
   ```

   여기서 next/future/image는 많이 생소할 것으로 생각한다. next/image를 안 쓴 결정적인 이유는 image태그가 html로 반환될 때 강제로 생겨나는 span 태그를 없앨 방법이 없기 때문이다.

   > 물론 span tag의 absolute 속성을 보면 알 수 있듯 이는 reflow를 최소화하기 위해 들어갔다. 하지만 나는 현재 이미지별로 크기와 높이가 랜덤이라 리플로우를 막을 방법이 없다. 보통은 이미 이미지를 띄울 화면 크기를 계산해두지만 나는 그럴 수 없으므로 span의 최적화 기능이 별 의미가 없다. 나에겐 이점이 별로 없는 태그지만 이 태그 때문에 스타일링은 더럽게 하기 힘들어진다. 그래서 span을 쓰지 않고자 next/future/image로 갈아탔다.
   >
   > 현재 reflow가 강제되어 있기에 이미지가 있는 부분에서 새로고침시에 글자가 튄다. 이 부분을 개선하기 위해서 이미지 태그에 높이 속성을 넣는 방안을 고려 중이다. 보통 이미지는 밑에 있고 이미지 최적화가 완료되면 사용자가 스크롤 내리기 전에 이미지 배치가 끝나기에 사용자는 별 이상 없이 쓸 거라고 합리화 중이다. 포스트 쓸 때 사진마다 넓이 높이 적어주기 좀 힘들다... (특히 next/image는 픽셀 값만 받아 픽셀로 적어줘야...)

   next/future/image는 실험 기능이라 그냥은 못 쓴다. next.config.js에 설정을 해줘야 한다. 실행 시에도 실험적인 기능 사용 중이니 리스크는 당신이 지세요 이러는 데 츤데레처럼 말은 그렇게 해놓고 잘 돌아가게 해두는 것 같다. 공식 문서 읽다 보니 나름 신경 쓰는 실험 기능인 듯 싶어서 그냥 쓰는 걸로 하였다.

   ```js
   /** @type {import('next').NextConfig} */
   const nextConfig = {
     reactStrictMode: true,
   
     experimental: {
       images: {
         allowFutureImage: true,
       },
     },
   
     images: {
       deviceSizes: [640, 1080, 1440, 2048],
       formats: ["image/webp"],
     },
   };
   
   module.exports = nextConfig;
   ```

이로써 끝이 났다. Next/image 태그를 쓰면 화면 사이즈 별로 이미지 제공하고 이미지 포맷을 webp와 같은 성능 좋은 포맷으로 바꿔주며 img 태그에 들어갈 최적화 옵션을 알아서 넣어준다. 자세한 건 [Next/image](https://nextjs.org/docs/api-reference/next/image)를 참고하자.

참고로 이런 매직 뒤에는 크게 두 가지 일이 일어난다.

1. 서버가 원본 이미지에서 사이즈별로 webp 포맷으로 변경된 이미지를 만들어야 한다. 참고로 서버만 해야 할 일은 아니다. 요새 AWS의 lambda@edge를 이용해 CDN에서 해당 일을 전담하게 할 수 있다. vercel도 비슷하게 돌아가는 듯싶으나 확인하진 못하였다.
2. 프론트엔드에서 img 태그의 src 값을 만들어진 webp 포맷의 변경된 이미지를 가리키도록 변경해야 한다.

참고로 vercel이 아닌 다른 배포 환경(AWS)에서는 1번이 자동으로 진행되지 않는 듯싶다. 하지만 나는 vercel를 쓰고 vercel은 이를 알아서 해주기에 그냥 저 태그로 끝내었다. [vercel의 이미지 최적화 비용](https://vercel.com/docs/concepts/image-optimization#source-images) 이걸 보면 횟수 제한 걸어두고 해준다.



### 결과...?

![image_optimization1_2](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization1_2.png)

* 우선 이미지 용량이 1.8MB에서 65.3KB로 줄었다. 나름 괜찮은 이미지 줄이기였다.
* 하지만 Size 별로 이미지 크기가 바뀌지 않았다. 내가 Next/Image의 사이즈 별로 이미지를 최적화하는 방식이 익숙지 않아서 그런 듯싶다. 아마 next.config.js에 size도 명시를 해야 했나 싶다. 100vw 쓰면 알아서 기기 사이즈에 맞춰줄 줄 알았으나 원본 사이즈 기준으로 동작하는 듯싶다.

![image_optimization1_2](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization1_3.png)

* 이거 성능 왜 이럴까요...? 물론 640ms가 엄청나게 불쾌한 시간은 아니지만 SSG를 쓰는데 이 정도면 슬프다. 

* 사실 실제로 쓰면 이미지가 CDN을 거쳐서 나오기 때문에 이렇게까지 느리지는 않다. 하지만 블로그 특성상 재방문한 유저보단 처음 방문하고 마는 유저가 더 많을 것이로 판단되어 캐시 미스 시의 속도도 중요하다고 판단하였다.

  

#### 해결 방법을 생각해보자.

1. vercel 이미지 최적화를 보니 내부 이미지는 파일 컨텐츠로 만들어진 해쉬로 외부 이미지는 원본 URL로 만들어진 URL로 주소가 변경된다고 한다. deploy된 이미지를 보니 public 폴더로 접근하는 이미지도 외부 URL로 인식되는 듯싶다.
2. vercel의 이미지 최적화 부분 비용 설명을 보면 런타임에 최적화 요청이 들어올 때까지 이미지 최적화와 관련된 카운트를 올리지 않는다고 되어 있다. 이 말은 즉 vercel이 요청이 들어올 때 이미지 최적화를 진행한다는 의미라고 볼 수 있다.
3. 요청 시에 이미지 최적화를 진행하니 시간이 오래 걸리는 거 같다. 어차피 빌드 시에 서비스에 필요한 이미지가 확정되니 빌드할 때 미리 최적화를 진행하면 안 되나 싶다. 만약 사용자가 이미지를 동적으로 업로드하면 업로드할 때 최적화를 하든지 아니면 이런 식으로 요청 시에 최적화를 해야겠지만 나는 그런 서비스와는 결이 다르다.



#### 결론은?

* 우선 라이브러리의 도움 없이 이미지 최적화를 진행하는 방법을 알아내야 겠다. 지금 생각나는 걸로는 포맷 변경, 사진 크기 조절 정도가 있겠다. 물론 블로그 쓸 때마다 이미지를 저런 식으로 바꿔주는 건 귀찮아서 되도록이면 자동으로 하게 할 생각이다.
* 빌드 시에 이미지 최적화를 진행해줄 서드 파티 이미지 최적화 툴을 이용해볼 생각이다. 이론상으로 서드 파티 라이브러리가 최적화된 이미지를 생성해주면 내가 next/image의 loader 부분을 통해 최적화된 이미지와 연결할 url를 설정해주면 된다. 잘 되었으면;;
* 만약 안된다면 커맨드 명령어로 이미지 포맷을 변경한 이후에 vercel에 푸시하는 방식을 이용할까 한다. 좀 많이 무식하지만 일일이 사진을 최적화시켜주는 것보단 낫잖아..

이미지 최적화는 중요하다. 다음 챕터는 기초 체력 신장을 위해 이미지 최적화와 관련된 기본적인 내용을 다룰까 한다.





