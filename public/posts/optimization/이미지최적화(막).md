---
title: Cuzz's Log 이미지 최적화(막) (with NextJS)
tags: ["optimization"]
uploadDate: 2022년 9월 17일
description: 이미지 최적화를 진행해보자(막)
---

포스트가 생각보다 더 길어졌다. 원래는 이렇게 질질 끌 생각은 없었으나 고쳐야 할 부분이 보이는데 그냥 넘어갈 수도 없어서 이미지 최적화 챕터에 글을 하나 더 쓰기로 하였다. 



### 문제가 되는 상황

현재 내 블로그의 이미지들은 전부 lazy 로딩이 적용된 상황이다. 덕분에 이미지 로딩이 특정 스크롤 위치에서 진행되기에 이미지에 높이와 넓이를 설정하지 않으면 어떤 현상이 발생하는지 정말 적나라하게 볼 수 있다.



<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization4_1.png" alt="image_optimization4_1" width="1220" height="520"/>

캐시 사용 중지를 걸어주고 블로그를 한번 리프레시해 주자. 그러면 이제 밑에 있는 이미지는 lazy loading이기 때문에 스크롤이 내려간 순간에 데이터를 요청할 것이다. 레이아웃이 변경되는 것을 적나라하게 보여주기 위해서 네트워크 속도를 느린 3G로 변경했다.

* 밑에 사진 두 개는 이미지 로딩 전과 이미지 로딩 이후를 나타낸다. 이미지 로딩 전에는 아무것도 없다가 이미지 로딩 후에 공간을 차지하게 되면서 스크롤이 밀리게 된다. 그냥 넘어갈 수 없다.

  

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization4_2.png" alt="image_optimization4_2" width="1220" height="520"/>

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization4_3.png" alt="image_optimization4_3" width="1220" height="520" />



### 고쳐보도록 하자

우선 기본으로 차지하는 크기를 알기 위해서 markdown을 작성하는 과정 중에 높이 정보와 넓이 정보를 입력해주어야 한다. Typora에서는 이미지를 HTML IMG 태그 형식을 사용해도 에디터에서 해당 태그에 맞게 이미지를 보여주기 때문에 markdown 내에 img 태그를 쓰는 방식으로 width와 height를 입력하였다.
```markdown
# 마크다운과
<img src="사진 주소" alt="image_optimization4_3" width="1220" height="520" />
## 이미지를 섞어써도 Typora는 렌더링을 잘한다.
```

일일이 블로그에 들어가는 이미지들의 넓이와 높이를 지정한 후에 imgRenderer 함수를 수정하였다. 수정하면서 기존에 srcset을 구하는 함수는 util 함수로 분리하였다.
```react
//getSecret.ts
const prefixs = ["520", "800", "1440"];

export default function getImageLocation(originSrc: string) {
  const srcSplit = originSrc.split("/");
  const name = srcSplit.slice(-1)[0].split(".")[0];
  const dirName = srcSplit.slice(0, -1).join("/") + "/optImage/";

  let srcset = "";
  srcset = prefixs.reduce((acc, cur) => {
    acc += `${dirName}${name}w${cur}.webp ${cur}w,`;
    return acc;
  }, srcset);

  let src = `${dirName}${name}w1440.webp`;

  return { srcset, src };
}


// postBody.tsx
function imgRenderer(props: any) {
  const { src, srcset } = getImageLocation(props.src);
  const { width, height, alt } = props;
  return (
    <OptImage
      alt={alt}
      srcSet={srcset}
      src={src}
      width={width}
      height={height}
      loading="lazy"
      decoding="async"
    ></OptImage>
  );
}
```

마지막으로 OptImage에서는 이미지가 로딩되지 않았을 떄 기본 화면을 제공한다. 나는 이미지를 감싸는 figure 태그에 CSS 속성을 부여하여 로딩 전 화면을 구현하였다.
```react
import { useState } from "react";
import cls from "src/utils/cls";

interface OptImageProps {
  alt: string;
  srcSet: string;
  src: string;
  width: string;
  height: string;
  loading: "lazy" | "eager";
  decoding: "sync" | "async" | "auto";
}

const OptImage = (props: OptImageProps) => {
  const [loading, setLoading] = useState(true);

  return (
    <figure
      className={cls(
        "relative my-[1.7777778em] mx-auto text-lg sm:text-xl w-[95%]",
        loading ? "border border-myOrange" : "border-none"
      )}
      style={{ aspectRatio: `${props.width} / ${props.height}` }}
    >
      {loading && <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">Loading Image...</span>}
      <img
        {...props}
        onLoad={() => setLoading(false)}
        style={{ aspectRatio: `${props.width} / ${props.height}` }}
      ></img>
    </figure>
  );
};

export default OptImage;

```



### 결과

* 이미지 로딩 중 화면과 관련하여

![image_optimization4_4](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization4_4.png)

이미지가 로딩 중에는 로딩 중임을 알려주는 문구와 로딩 후 이미지가 차지해야 할 공간을 알려주는 테두리가 그려진다. 나름 만족할만한 결과였다.

* 그래서 성능은?

![image_optimization4_5](/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/optimization/image/image_optimization4_5.png)

아니 SSG로 돌리는 거 아닌가? 왜 이렇게 느린가 싶다. 원인을 찾아보니 서버 쪽에서 응답이 느리다고 나온다. 내가 만약 서버를 직접 운영했다면 어떤 부분이 문제인지 알아내려고 노력했겠지만, 지금은 vercel를 써서 그게 좀 힘들다. 그래도 SSG로 돌아간다는 건 vercel의 로그를 보고 알았으니 그냥 내가 hobby 버전을 써서 느린가 보다 해야겠다. 

> 간단하게 진행할 줄 알았던 작업이 생각보다 오래 걸렸다. 성능 지표가 엄청 좋지 못한 게 아쉽지만, 기존보다 조금이라도 더 높은 점수를 받았으니 만족해야겠다. 열심히 성능을 위해 공부한 나 자신을 칭찬하며 이미지 최적화 시리즈는 마무리할까 한다.
>
> 다음은 번들링 사이즈 최적화를 할 예정이다. lighthouse에서 의미 없는 자바스크립트 파일이 있다고 경고를 했기 때문에 이를 어떻게 찾아내어 제거할 것인지 알아볼 것이다. 재미없는 글 읽느라 고생 많았다.
