---
title: 성공과 실패를 결정하는 1%의 네트워크 원리 제 1장. 웹 브라우저가 메시지를 만든다.
uploadDate: 2022년 9월 27일
description: 성공과 실패를 결정하는 1%의 네트워크 원리를 읽은 후 내용을 정리한 블로그입니다. 차례는 그대로 따라가나 저의 말로 풀어서 정리할 예정입니다. 추가로 공부한 내용도 정리할 예정입니다.
---

성공과 실패를 결정하는 1%의 네트워크 원리(이하 1% 네트워크 원리)의 첫 번째 장인 웹 브라우저가 메시지를 만든다를 읽고 이를 블로그에 정리해보았다. 이번 챕터는 브라우저에 요청이 발생해서 OS socket 인터페이스로 데이터를 전송하는 단계까지 설명하는 챕터이며 대부분의 내용이 HTTP 설명과 DNS 구조 설명, OS socket 인터페이스 설명이다.

### 01. HTTP 리퀘스트 메시지를 작성한다.

#### 브라우저와 URL

- URL에는 https:// 으로만 시작하는 것 같지만 ftp://, file:// 등 여러 가지 문자로 시작할 수 있다. 이게 브라우저는 단순 웹 서버의 클라이언트 뿐만 아니라 메일 서버의 클라이언트, FTP의 클라이언트 등 여러 종류의 프로토콜에 관련된 클라이언트 역할도 수행할 수 있기 때문에 해당 브라우저가 어떤 프로토콜의 클라이언트인지 명시해줄 필요가 있기에 URL의 시작 지점에 어떤 프로토콜을 쓰는지 명시해준다.
- 맨 앞 부분에 정의된 프로토콜에 따라 뒤에 오는 문자열의 문법 구조가 달라진다.
- 브라우저는 URL에 문자열이 입력되면 리퀘스트 메시지를 만들기 위해 해당 URL를 해독한다. http 프로토콜의 경우 서버에 요청할 html 파일의 경로가 프로토콜을 명시하는 부분 이후에 들어간다.

#### HTTP의 기본 개념

- HTTP 프로토콜은 클라이언트가 서버에게 무엇을 어떻게 해달라고 요청하면 서버가 이에 맞춰 동작하고 클라이언트에게 결과를 응답한다. 무엇을에 해당하는게 URI이고 어떻게에 해당하는게 HTTP method 이다.

- 상세한 문법으로 들어가면 HTTP 요쳥의 경우 첫 번째 줄에는 HTTP 메서드의 종류, URI(URL), HTTP 버전이 공백으로 구분되어 들어가고 바로 다음에 필드명과 필드값으로 매핑되어 있는 HTTP 헤더 정보가 들어간다. 한 줄을 띄워준 이후에 메시지 본문이 들어간다.

- HTTP 응답의 경우 HTTP 버전, 요청이 잘 처리되었는지 여부를 나타내는 상태 코드, 응답 문구가 공백으로 구분되어 들어가고 바로 다음에 필드명과 필드값으로 매핑되어 있는 HTTP 헤더 정보가 들어간다. 한 줄을 띄워준 이후에 메시지 본문이 들어간다.

- HTTP 헤더는 해당 요청 또는 응답에 부가적인 정보를 표현하며 요청에만 쓸 수 있는 요청 헤더, 응답에만 쓸 수 있는 응답 헤더, 둘 다 쓸 수 있는 범용 헤더로 구분된다. 메시지 본문에 대한 설명, 캐시 적용 여부, 인증 로직 여부 등 통신과 관련된 다양한 정보를 헤더를 통해서 관리힌다. 헤더와 관련된 내용은 따로 포스팅할 예정이다.

- 응답 헤더의 status 코드는 1xx, 2xx, 3xx, 4xx, 5xx 번대로 구성되어 있으며 각 번호대는 각자의 의미가 정해져 있다. 각 번호대에 숫자 코드들도 다 의미가 있는데 (401은 unauthorized를 의미) 이런 건 그때그때 찾아보자.

  | 코드값 |                  설명                   |
  | :----: | :-------------------------------------: |
  |  1xx   |    처리의 경과 상황 등을 통지합니다.    |
  |  2xx   |                정상 종료                |
  |  3xx   | 무언가 다른 조치가 필요함을 나타냅니다. |
  |  4xx   |           클라이언트측의 오류           |
  |  5xx   |              서버측의 오류              |

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/network/image/network01_01.png" alt="1의네트워크01_01" width="870" height="380"/>

#### 보충 설명 1. URI / URL

URI는 Uniform Resource Identifier의 줄임말로 웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열이다. URL은 Uniform Resource Locator로 인터넷에서 리소스의 위치를 가리키는 문자열이다.

URI는 **물리적 리소스를 식별**하는 고유한 문자열이고 URL은 **리소스의 위치를 가리키는** 문자열이다. 이때 URL에서 리소스의 위치를 이용해 리소스를 식별할 수 있으며 하나의 리소스는 하나의 위치에 대응되므로 (파일 이름이 같은데 다른 파일일수는 없다.) URL을 URI로 쓸 수 있다.

즉 URI는 URL를 포함하는 개념이라고 볼 수 있다.

#### 보충 설명 2. HTTP 메서드

HTTP 메서드는 개념으로 아는 것도 중요하지만 잘 쓰는 것도 중요하다. 우선 MDN 문서를 보면서 어떤 메서드가 있는지 한번 쭉 정리하도록 하겠다.

| 메서드  | 요청에 Body | 응답에 Body |  안전  |  멱등  |     캐시 가능      |
| :-----: | :---------: | :---------: | :----: | :----: | :----------------: |
| CONNECT |   아니요    |     예      | 아니오 | 아니오 |       아니오       |
| DELETE  |     May     |     May     | 아니오 |   예   |       아니오       |
|   GET   |   아니오    |     예      |   예   |   예   |         예         |
|  HEAD   |   아니오    |   아니오    |   예   |   예   |         예         |
| OPTIONS |   아니오    |     예      |   예   |   예   |       아니오       |
|  POST   |     예      |     예      | 아니오 | 아니오 | 신선도 정보 포함시 |
|   PUT   |     예      |   아니오    | 아니오 |   예   |       아니오       |
|  TRACE  |   아니오    |   아니오    |   예   |   예   |       아니오       |

안전은 **서버의 상태를 바꾸는지의 여부**이고 멱등은 **여러 번 수행해도 똑같은 행위를 하는지 여부**이다. POST와 PUT은 둘 다 서버의 상태를 변경시킬 수 있기 때문에 안전하지 않지만 POST의 경우 이미 리소스가 있는 경우와 없는 경우 동작이 달라지지만 PUT은 리소스가 있던 없던 지우고 생성하기에 동작이 똑같다.

POST 요청을 캐싱하는 경우는 POST 요청의 응답 값이 추후 GET이나 HEAD에 쓰일 때로 한정된다. 애초에 서버에 변경을 가하는 메서드는 무조건 서버에 도달해야 하기 때문에 캐시가 불가능하기에 POST의 결과값을 캐시하는 경우는 지극히 제한적이다. https://www.mnot.net/blog/2012/09/24/caching_POST

각 메서드에 대한 자세한 설명은 매우 길어질 것 같아 따로 블로그 글을 파서 쓸 생각이다. CONNECT, HEAD, OPTIONS, TRACE와 같은 메서드가 뭐하는 아이들인지와 PUT, DELETE, GET, POST를 어떻게 쓰면 좋을지 작성해볼 예정이다.

### 02. 웹 서버의 IP주소를 DNS 서버에 조회한다.

브라우저는 URL를 분해하고 HTTP 리퀘스트 메시지를 만들 수 있지만 이걸 서버로 보낼 능력은 없다. 대신 OS에 데이터를 전송하고 받아오는 것을 의뢰해서 작업을 수행한다. 이때 OS에게 IP 주소를 건네주어야 하는데 우리의 URL에는 IP 주소는 없고 해당 서버의 도메인 네임만 존재한다. 그래서 브라우저는 DNS에 특정 도메인과 매핑되어 있는 IP주소를 물어보는 과정을 거친다.

#### IP 주소의 기본

- 우선 현재 IP 체계는 IPv4로 총 32비트로 표현되며 0.0.0.0 ~ 255.255.255.255의 범위를 가진다.
- IP 주소는 크게 호스트 번호와 네트워크 번호로 나뉜다. 네트워크 번호는 자신을 포함하는 네트워크를 식별하는 부분이고 호스트 번호는 해당 네트워크 내에서 자신을 식별하는 부분이다. 옛날에는 클래스를 기준으로 네트워크 번호를 나누었는데 클래스 A는 앞에 8비트가 네트워크 번호였고, 클래스 B는 앞에 16비트 , 클래스 C는 앞에 24비트였다.
- 쓰다보니 만약 내가 컴퓨터가 만대라서 클래스 B의 IP를 할당받았다면 5만 5천 개 정도의 IP 자원이 낭비되는 셈이다. IP 낭비를 줄이고자 네트워크를 작게 분할하는 서브넷팅이라는 기술이 도입되었다. 해당 기술을 이용해 클래스 B인 네트워크를 여러 서브 네트워크로 쪼개고 네트워크 번호의 비트에 해당 서브넷을 구분할 수 있을 정도의 비트를 추가하였다. 서브넷으로 분리되었어도 이를 구분할 수 있는 비트가 추가되었기에 네트워크 번호를 통해 호스트가 있는 네트워크를 특정할 수 있게 되었다.
- 다만 서브넷을 쓰게 되면 네트워크 번호의 길이가 자기 멋대로 변하게 된다. 그래서 현재 IP 주소를 쓸 때에는 넷마스크 정보를 두어 어디까지가 네트워크 번호인지를 판단한다.

#### 도메인 네임

- 사람의 입장에서는 번호로 이루어진 IP 주소보다는 서버의 이름인 도메인이 더 기억하기 쉬웠다. 그렇다고 도메인으로 통신시스템을 구축하기에는 도메인을 표현하기 위해 드는 리소스의 낭비가 너무 컸다. 그래서 브라우저에서는 도메인 네임을 쓰고 대신 실제 통신할 때에는 도메인 네임을 IP로 바꿔서 통신하는 시스템을 구축한다.
- 특정 도메인 네임을 IP로 바꾸기 위해서는 도메인 네임과 IP 주소의 쌍을 저장하고 있는 DNS 서버에 요청을 보내야 한다. 다행히 네트워크 기능을 활용하기 위한 부품집인 socket 라이브러리에 있는 리졸버를 이용해 구현할 수 있다. DNS의 클라이언트 역할을 하는 아이를 **DNS 리졸버**라고 하고 이렇게 IP를 찾아내는 행위를 **네임 리졸루션**이라고 한다.
- 리졸버도 자기가 직접 통신을 다 수행하지는 않는다. 네트워크가 그렇듯 자기 계층에서 할 일만 딱하고 나머지 일은 자기 밑 계층에 있는 아이에게 던져버린다. 여기서는 실제 통신 과정을 OS 내부 프로토콜 스택에게 맡겨버린다.

### 03. 전 세계의 DNS 서버가 연계하다.

하나의 DNS 서버가 세상의 모든 도메인을 관리할 수 없다. 그렇다고 아무렇게나 도메인 정보를 뿌려두면 특정 도메인의 IP주소를 찾기 위해 최악의 경우 모든 DNS를 다 뒤져야 할 수도 있다. 다행히 DNS는 계층 구조로 이루어져 있어 빠르게 특정 도메인의 정보를 가지고 있는 DNS에 접근할 수 있다.

#### DNS 서버의 기본 동작

- DNS 클라이언트는 이름, 클래스, 타입 정보를 바이트 형식으로 DNS에 보낸다. 이름은 내가 IP 주소를 알고 싶어하는 도메인이고 클래스는 IP로 네트워크 계층이 결정되기 전 다른 네트워크 프로토콜을 지원하기 위해 만들어진 필드이며 타입은 이름에 어떤 타입의 정보가 지원되는지를 나타낸다.
- DNS 서버에는 이름, 클래스, 타입, 리턴값으로 이루어진 레코드를 테이블 형태로 가진다. DNS 클라이언트의 요청에 이름, 클래스, 타입 값을 테이블에 대입해 적절한 리턴 값을 찾아서 리턴해주는게 DNS서버가 하는 일이다.

#### 내 도메인 정보를 가지고 있는 DNS 찾기

> cuzz.ac.kr이라는 도메인이 있다고 가정하자.

- 우선 내 컴퓨터에 기본 설정된 DNS 서버로 이동한다. 여기서 특정 도메인의 IP 주소를 찾을 수 있으면 끝이다.
- cuzz.ac.kr은 사실 cuzz.ac.kr. 이다. .은 루트 도메인으로 모든 도메인의 시작이라 볼 수 있으며 평상시에는 생략해서 쓰기에 그 존재 자체를 모를 수 있다. 암튼 .를 통해 kr 도메인을 관리하는 DNS 주소를 아는 루트 DNS로 이동한다.
- 루트 DNS에서 kr DNS를 알아내고 kr DNS에서 ac DNS를 알아내고 마지막으로 ac DNS에서 cuzz.ac.kr.의 IP 주소를 발견할 수 있게 된다. 이런 방식으로 어떤 주소이든지 상위 도메인서부터 타고 내려가면 금방 찾을 수 있다.

### 04. 프로토콜 스택에 메시지 송신을 의뢰하다.

통신을 구현하는 소프트웨어는 모두 OS의 소켓 라이브러리를 이용하며 웹 브라우저도 예외는 아니다. 이번 장에서는 통신을 하는데 있어서 어떤 식으로 소켓 라이브러리를 이용하는지 살펴보고자 한다.

- 데이터 송수신은 socket을 이용하면 러프하게 네 단계로 나눌 수 있다. 1) 소켓을 만든다. 2) 서버측 소켓에 파이프를 연결한다. 3) 데이터를 송수신한다. 4) 파이프를 분리하고 소켓을 말소한다.
- 참고로 저 네 가지 과정을 실행하는 것은 OS 내부의 프로토콜 스택이다. 지금 우리는 저 행위를 소켓 라이브러리를 이용해 어떻게 지시하는지를 배우는 것이다. 지시한 내용을 어떤 방식으로 실행하는지는 다음 장에서 배울 것이다.
- 소켓 라이브러리의 소켓 생성 함수를 이용하면 해당 함수는 특정 소켓을 가리키는 디스크립터를 리턴한다. 애플리케이션은 디스크립터를 이용해 자신이 이용하는 소켓을 구분한다.
- 사실 서버와 통신하기 위해서는 IP 말고도 추가적인 정보가 필요하다. 바로 어떤 소켓과 통신할지 알아야 한다. 클라이언트 측에서 애플리케이션이 자신이 쓸 소켓을 구분하기 위해 디스크립터를 사용한다면 클라이언트가 서버 측 소켓을 특정하기 위해서 포트 번호를 이용한다. 잘 알려진 서비스는 포트 번호가 이미 지정되어 있기 때문에 (웹 서버는 80) 해당 포트 번호를 이용하는 건 어렵지 않다.
- IP 와 포트 번호를 이용해서 소켓 간에 파이프가 형성되었다면 이를 이용해 데이터를 송수신하고 송수신이 완료된 이후에는 소켓을 닫는다.

#### 출처

IP 주소와 관련된 추가 정보 by https://better-together.tistory.com/118
