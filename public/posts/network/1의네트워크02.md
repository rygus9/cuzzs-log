---
title: 성공과 실패를 결정하는 1%의 네트워크 원리 2장
uploadDate: 2022년 10월 1일
description: 성공과 실패를 결정하는 1%의 네트워크 원리를 읽은 후 내용을 정리한 블로그입니다. 차례는 그대로 따라가나 저의 말로 풀어서 정리할 예정입니다. 최대한 책 내용을 따라가나 중간중간 개인적인 생각이 포함될 수 있습니다.
---

이번 장은 OS 단의 프로토콜 스택에서 일어나는 동작을 러프하게 설명한 장이다. TCP/IP의 동작 과정을 개략적으로 설명하고 이더넷이 어떤 방식으로 신호를 전달하는지 개략적으로 설명한다. 학교에서 진행하는 컴퓨터 네트워크 수업 내용을 1장에 요약한 느낌이다. 아쉬웠던 점은 이번 장에서 TCP/UDP 부터 IP 이더넷까지 다 설명하려다 보니 정작 TCP/UDP 부분이 조금 부실해지고 IP와 이더넷 부분은 설명이 모호해진 느낌이었다. 이번 장에서 TCP/UDP를 확실하게 하고 다음 장에서 IP와 이더넷을 확실하게 다루었으면 더 좋지 않았나 싶다. 정리할 때에도 IP와 이더넷 부분은 적당히할 생각이다.



* 시작하기 전 전반적인 큰 그림

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/network/image/network02_01.png" alt="network02_01" width="800" height="340"/>

네트워크는 하청 구조와 비슷하다. 현실에서는 맨 아래 있는 하청 업체가 모든 걸 다하는 느낌이 강하지만 네트워크 세계에서는 하청을 시키는 쪽도 열심히 일하고 자기가 못하는 부분만 하청을 시키는 나름 바람직한 하청 구조다. 통신이라는 작업이 매우 복잡하다 보니 통신 과정을 여러 단계를 나누고 독립화시킨 이후 하나의 기기는 하나의 단계만 수행하고 나머지 단계는 의뢰를 맡기는 식으로 발전하였다.





### 01. 소켓을 작성한다.

socket 라이브러리의 의뢰를 수행하는 프로토콜 스택은 세부적으로 보면 상하구조를 가진다. 계층 상 위에 있는 프로토콜은 작업을 의뢰하고 밑에 있는 프로토콜은 작업을 수행하는 형식이다. 네트워크 애플리케이션부터 LAN 어댑터까지 계층 관계를 표현하면 밑과 같다. 참고로 왼쪽으로 갈수록 높은 위치에 있는 요소이다.

> (네트워크 애플리케이션 => 소캣 라이브러리) => (TCP 또는 UDP 프로토콜 => IP 프로토콜) => (LAN 드라이버) => (LAN 어댑터)



#### 소켓은 뭔가요?

소켓은 개념적인 것이어서 실체는 없지만 굳이 표현하자면 통신 동작을 제어하기 위한 정보를 보관하는 메모리 영역이라고 볼 수 있다. 프로토콜은 스택에 쓰인 제어 정보를 참조하며 동작한다. 애플리케이션 관점에서 소켓은 복잡한 통신 관련 OS 기능들을 감싼 인터페이스라고 볼 수 있다. 조금만 socket 라이브러리 수도 코드를 뜯어보도록 하자.

```c
디스크립터 = socket(<IP 관련>, <TCP/UDP 관련>); 
connect(디스크립터, ...)
write(디스크립터, ...)
read(디스크립터, ...)
close(디스크립터)
```

* socket이라는 함수를 통해 프로토콜 스택에 소켓을 위한 메모리 영역을 할당한다. 리턴 값으로 OS 프로토콜 내 존재하는 수많은 소켓과 구분하기 위한 이름인 디스크립터를 반환한다.
* socket 함수로 소켓을 열었으면 해당 소켓을 이용해 소켓 라이브러리가 제공하는 여러 통신 관련 함수를 사용할 수 있다. 물론 소켓 라이브러리는 의뢰만 할 뿐 직접 수행하는 건 OS 프로토콜 스택이다.





### 02 서버에 접속한다.

* 접속 동작은 TCP인지 UDP인지에 따라 다릅니다. 이번 장은 TCP임을 가정하고 접속 동작을 서술합니다.

소켓을 생성한다고 해서 바로 상대방과 통신할 수 있는 건 아니다. 생성 직후 소켓은 메모리 공간에 통신을 위한 제어 정보가 하나도 없는 상태이다. 접속 동작의 첫 번째는 통신 상대와 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송, 수신이 가능한 상태로 만드는 것이다. 실제 통신하는 과정에서 오고 가는 데이터를 일시적으로 저장하는 버퍼 메모리 확보도 접속 동작에 실행된다.



#### 제어 정보?

제어 정보는 크게 두 가지로 나눌 수 있다. 하나는 클라이언트와 서버가 서로 연락을 절충하기 위해 서로 주고받는 제어 정보이고 나머지 하나는 클라이언트 또는 서버가 통신을 제어하기 위해서 각자 가지고 있는 제어 정보이다.

* 헤더 : 클라이언트와 서버가 서로 주고받는 제어 정보는 헤더에 기록한다. 헤더는 보낼 데이터의 앞에 붙으며 헤더 안의 데이터 구성은 해당 헤더가 담당하는 프로토콜에 따라 달라진다. TCP와 관련된 제어 정보를 담당하는 헤더는 TCP 헤더, IP와 관련된 제어 정보를 담당하는 헤더는 IP 헤더인 것처럼 어떤 부분을 담당하는지에 따라 헤더의 구성이 달라진다.

  특정 프로토콜의 헤더가 어떻게 구성되어 있고 어떤 동작을 의미하는지 안다는 것은 해당 프로토콜의 통신 동작을 이해했다고 봐도 좋을 만큼 헤더에는 해당 프로토콜의 동작 전반을 나타내는 정보가 축약되어 있다.

* 소켓에 기록하는 제어 정보 : 헤더만 이용해서는 통신을 제대로 완료하기 힘들다. 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등 헤더 정보 이외에도 통신에 관여하는 데이터는 많다. 이런 데이터들은 소켓에 따로 기록해두며 이 제어 정보는 상대 측에서 볼 수 없다. 소켓에 기록하는 제어 정보는 프로토콜 스택을 구현하는 사람에 따라 달라지기 때문에 간단히 설명할 수는 없다. 하지만 어떤 프로토콜 스택이든 중요한 정보는 볼 수 있도록 명령어를 제공해준다.



#### 접속 동작의 실체 (TCP)

```c
connect(디스크립터, 서버측의 IP 주소와 포트 번호)
```

* 설명하기 전에 확실히 해야할 점이 두 가지가 있다.
  1. 해당 접속 동작은 TCP입니다.
  2. 소켓 => TCP 담당 부분 => IP 담당 부분  ~(여러 가지 일들)~  IP 담당 부분 => TCP 담당 부분 => 소켓으로 통신이 진행됩니다. TCP 부분 위주로 설명한다 해도 실제 실무는 그 아래 계층에서 한다는 점을 꼭 기억하길 바란다.

1. 연결하려는 측에서 socket의 port 정보를 적고 TCP 헤더의 컨트롤 비트인 SYN이라는 비트를 1로 만든다. 해당 컨트롤 비트는 해당 소켓이 TCP 연결을 요구한다는 의미를 가진다. 그리고 IP 담당 스택에게 해당 데이터를 전송해달라고 의뢰한다.
2. 받는 측에서는 IP 담당 스택을 통해 port 값과 같은 socket에 데이터가 도착하게 된다. 받는 측에서는 잘 받았다는 의미로 데이터를 수신하는데 이때 ACK라는 컨트롤 비트를 1로  만듭니다. 또한 받는 측으로도 연결해야 하니 SYN 컨트롤 비트도 1로 만들어둡니다. 
3. 연결하는 측에서는 SYN과 ACK 두 가지 정보를 받습니다. 연결하는 측에서는 자신이 보낸 SYN 패킷에 대한 ACK 응답을 받았으니 소켓에 접속 완료를 나타내는 제어 정보를 기록합니다. 이와 동시에 서버에서도 SYN을 보냈기 때문에 자신도 ACK 신호를 보냅니다. 
4. 받는 측에서 ACK 신호를 받으면 접속 완료입니다.

이 일련의 과정을 3 way Handshake라고 부른다.

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/network/image/network02_02.png" alt="network02_02" width="800" height="340" />

이게 물리적으로는 달라진 점이 없지만 TCP 계층 상 논리적으로 연결이 성립된 것이다. IP 프로토콜이 정립되기 전에는 물리적인 경로를 설정하는 프로토콜도 있었다고 했지만 이제는 그런 게 없으니 TCP 상에서 연결이 성립되었어도 실제 물리적으로 바뀌는 게 없다. 대신 로스 패킷 회복 기능과 같은 논리적인 연결을 위한 TCP 기능들이 추가되었기에 TCP 계층 위애서는 실제로 연결되어 있다고 가정하고 생각하고 사용해도 크게 문제가 없다.





### 03. 데이터를 송수신한다.

#### 송신 의뢰하기

프로토콜 스택은 의뢰를 받은 데이터를 바로 보내는 게 아니라 자체 내부에 있는 송신용 버퍼 메모리 영역에 저장하고 추후에 한꺼번에 보낸다. 이런 방식을 고안한 이유는 애플리케이션이 송신 의뢰를 할 때마다 보내는 건 비효율적일 수 있기 때문이다. 어떤 애플리케이션은 정말 간단한 데이터를 여러 번 송신 의뢰할 수 있는데 한꺼번에 모아서 가도 될 내용을 하나하나 다 보내는 건 낭비다. 그래서 버퍼 메모리에 어느 정도까지 저장하고 그 이후에 실제로 데이터를 송신한다.

1. 한 패킷에 저장할 수 있는 데이터의 크기로 송신용 버퍼 메모리에 있는 데이터를 송신할지 결정한다. 프로토콜 스택은 MTU라는 매개변수를 바탕으로 데이터 용량을 파악한다. (MTU는 애플리케이션 데이터 + TCP/IP 헤더, 애플리케이션 입장의 데이터는 따로 MSS라고 부른다.) 애플리케이션에서 받은 데이터가 MSS (MTU - TCP/IP 헤더)를 초과하거나 근접하면 송신하면 통신 효율을 높일 수 있다.
2. 송신 속도가 느려질 경우 버퍼가 다 채워질 때까지 보내는 건 안 그래도 느린 속도를 더 느리게 만든다. 빠르게 동작할 필요가 있을 때에는 버퍼 메모리에 가득 차지 않아도 보내야 한다.

시간과 효율은 반비례한다. 오랜 시간을 기다라면 효율이 올라가는 구조이기에 이를 프로토콜 스택에만 맡기는 건 좋지 않다. 보통은 애플리케이션 입맛에 맞춰서 쓰라고 송신 타이밍을 제어할 수 있는 옵션을 제공한다. 



#### TCP의 회복 조치

TCP는 모든 수신에 대한 결과로 ACK를 응답하게 되어있다. 그래서 데이터를 보내는 쪽은 ACK 응답이 없을 시 네트워크에 이상이 있다고 판단하고 해당 데이터를 다시 보내는 회복 조치를 취한다. 덕분에 TCP 계층 밑에서 에러로 인해 패킷이 사라져도 TCP 계층에서 회복 조치를 통해 이를 바로잡아준다.

TCP가 회복 조치를 취하기 때문에 TCP 밑에 있는 라우터, 허브, 스위치 등등은 따로 회복 조치를 취하지 않는다. 에러가 나거나 이상하면 패킷을 그냥 버린다.

실제 오류 검출과 회복의 원리는 꽤 복잡하다. 핵심이 되는 ACK가 돌아오는 시간인 타임아웃에 대해서만 설명하자면 타임아웃을 길게 잡으면 느리게 오는 패킷까지 기다릴 수 있지만 통신 속도가 느려지고 타임아웃을 짧게 잡으면 실제로 패킷이 잘 오고 있는데 다시 보내는 비효율이 생길 수 있지만 실제 패킷 로스가 발생했을 경우에 짧은 타임아웃 시간 덕분에 빠르게 대응할 수 있다.

통신망 상태에 따라서도 타임아웃 간격을 조절하는 게 좋기 때문에 TCP 프로토콜에서는 이전에 ACK가 도착하는 데 걸린 시간을 기반으로 타임아웃값을 동적으로 수정한다. 

* RTT (Round Trip Time) : 패킷이 목적지에 도달한 후, 그에 대한 응답이 돌아오기까지의 시간



#### 긴 데이터를 분할하기

TCP는 데이터가 한 패킷에 들어가지 않으면 MSS 크기에 맞게 데이터를 분할하고 보내며 수신 측에서 분할된 데이터를 받아서 조립할 때 순서를 보장해준다. 당연히 수신 측에서 패킷을 잘 받았는지 여부도 확인해준다. 그림 자료도 있는데 나중에 윈도우까지 적용된 버전으로 그리려고 한다.

* ACK 번호는 시퀸스 번호 + 받은 데이터(MSS)의 크기이다.
* 맨 처음 시퀸스 번호는 무조건 1로 하면 이 규칙을 아는 누군가에 의해 악용될 수 있기 때문에 접속 과정 중에서 랜덤으로 정한다.



#### 윈도우 제어 방식 도입

보낼 데이터가 있는데 ACK가 오지 않았다는 이유로 모든 작업을 블락하는 건 비효율적이다. 이에 서버 측 수신 메모리 버퍼의 용량이 여유가 있다면 ACK 값이 돌아오는 것과 상관없이 일단 계속 데이터를 보내자는 게 윈도우 제어 방식의 핵심이다.

* 접속 동작 시에 서버와 클라이언트 모두 자신의 수신 메모리 버퍼 용량을 교환한다.
* 데이터를 보내는 측은 자신이 가지고 있는 수신 측 메모리 버퍼 용량만큼 요청을 보낸다.
* 수신 측에서는 데이터를 받고 해당 데이터를 수신 메모리 버퍼에서 비우면 ACK 신호와 함께 남아있는 메모리 용량을 보낸다.
* 만약 수신 메모리 버퍼를 비우기 전에 다음 데이터가 들어왔다면 ACK를 다음 데이터 기준으로 한 번만 보낸다.이전 ACK까지는 잘 받았다고 퉁치는 방식이며 이를 cumulative ACK라고 한다.

사실 윈도우 제어 방식과 회복 처리 과정, cumulative ACK를 연계하면 생각보다 복잡하다. 

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/network/image/network02_03.png" alt="network02_03" width="800" height="340" />



### 04. 서버에서 연결을 끊어 소켓을 말소한다.

통신이 완료되면 서버에서 연결을 끊는다. 물론 HTTP 1.1에서는 연결을 유지하는 기능이 추가되었고 이 때문에 클라이언트에서 먼저 연결을 끊을 수 있지만 이 장에서는 서버가 먼저 연결을 끊는 걸로 설명한다.

1. 서버에서 FIN 송신 (SYN과 비슷한 컨트롤 비트, 소켓 닫기를 의미한다.)
2.  클라이언트에서 FIN 수신, ACK 송신, FIN 송신
3. 서버에서 FIN 수신, ACK 송신

참고로 FIN에 대한 ACK를 수신했다고 해서 바로 소켓을 닫지는 않는데 위의 경우에서 서버에서 보낸 ACK가 소실되는 경우 클라이언트가 FIN이 도달하지 않는 것으로 간주하고 다시 FIN을 보낼 수 있기 때문이다. 그래서 다시 보내는 동작이 멈추는 시간 정도만큼 소켓을 열어두었다가 말소시킨다.





### 05. IP 와 이더넷의 패킷 송수신 동작

현재까지는 TCP 담당 부분에서 어떤 방식으로 통신이 동작하는지 살펴보았다. 이번 장에서는 IP 담당 부분과 그 밑 부분이 어떤 방식으로 작동하는지 개략적으로 살펴볼 예정이다. 라우터나 허브, 스위치의 자세한 설명은 다음 장에 예정되어 있기에 이번 장은 가볍게? 진행되었다.



#### 동작 개요

패킷 : 헤더와 데이터로 이루어져 있다. 앞의 헤더가 IP 헤더면 IP 패킷, TCP 헤더면 TCP 패킷이 된다.

IP 담당 부분은 TCP 담당 부분이 준 데이터에 IP 헤더를 붙인 후 MAC 헤더를 붙인다. IP 헤더는 IP 주소로 표시된 목적지까지 보내기 위해 사용하는 제어 정보를 MAC 헤더는 이더넷 등 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보를 기록해두었다.

라우터는 특정 패킷의 IP 헤더를 보고 다음 라우터에 해당 패킷을 보낸다. 허브는 서브넷 안에서 특정 패킷의 MAC 헤더를 보고 해당 패킷을 운반해 다음 라우터까지 도착시킨다.IP는 경로를 설정하는 역할을 이더넷은 실제로 해당 경로까지 연결하는 역할을 담당한다. 이렇게 작업을 분담했기 때문에 이더넷에 해당하는 부분은 다른 것으로 대체할 수 있다.



#### IP 담당 부분 탐구

1. 우선 IP 헤더를 만들어서 TCP 헤더 앞에 붙인다. 이때 수신처 IP 주소와 송신처 IP 주소가 필요하다. IP 주소는 LAN 어댑터에 발급되는 것이고 하나의 컴퓨터에 여러 개의 LAN 어댑터를 장착할 수 있기 때문에 송신처의 IP 주소도 선택한다는 건 어떤 LAN 어댑터로 데이터를 보낼지 정하는 것과 같다.

   수신처 IP와 송신처 IP를 적었으면 프로토콜 번호라는 필드에도 값을 채워준다. 이 필드에는 IP 패킷이 전달하고 있는 데이터의 프로토콜 성격을 나타내는 부분으로 TCP면 06(16진수), UDP면 17(16진수) 이런 식으로 나타낸다. 채워야 할 값은 더 있지만 다음 장에서 다루도록 하자.

2. IP 헤더를 만든 이후에는 MAC 헤더를 만든다. 이더넷은 TCP/IP와는 다른 구조로 패킷의 수신처를 판단하기에 MAC 헤더가 꼭 필요하다. MAC 헤더에는 수신처의 MAC 주소, 송신처의 MAC 주소, 이더 타입이 값으로 들어간다. 이더 타입은 해당 필드 뒤에 이어지는 것이 패킷의 내용물이기에, MAC 헤더의 위치를 구분하는 역할을 하면서 동시에 그 뒤에 이어지는 내용물의 종류를 나타내는 역할을 한다.

   MAC 주소는 LAN 어댑터를 제조할 때부터 정해지는 값으로 어댑터 안의 ROM에 영구 저장되는 값이다. 48비트로 구성되어 있으며 계층 구조를 띄고 있는 IP와 달리 그냥 고유 값을 할당받는다.

3. 받은 IP 주소 => **IP 테이블로 다음 목적지 IP를 찾아냄** => **다음 목적지 IP에 맞는** 수신처의 MAC 주소가 필요 => ARP 프로토콜의 등장

4. 왜 IP 담당 부분이 MAC 헤더까지 만드느냐면 IP 담당 부분이 IP 헤더만 만든다면 그 밑에 있는 LAN 어댑터는 IP 프로토콜에 맞게 만들어져야 한다. 이러면 IP 프로토콜을 따르지 않는 패킷은 전송할 수 없게 된다. 하지만 MAC 헤더까지 붙인다면 IP 프로토콜을 사용하지 않더라도 MAC 헤더만 붙이면 LAN 어댑터에서 처리할 수 있다. 즉 좀 더 여러 패킷에 대응하는 LAN 어댑터를 사용하기 위해 MAC 헤더까지 만든다고 생각하면 좋을 듯싶다.



#### ARP(Address Resolution Protocol) 프로토콜

이더넷에는 연결된 모든 전원에게 패킷을 전달하는 브로드캐스트 기능이 있는데 이를 이용해서 전원에게 특정 IP를 가진 LAN 어댑터가 있는지 질의한다. 이런 방식으로 상대가 자신과 같은 네트워크에 존재하면 MAC 주소를 알아낼 수 있다.

참고로 매번 MAC 주소를 ARP 프로토콜로 알아내는 건 낭비가 심하므로 한 번 조사한 결과를 ARP 캐시에 저장한다. 다만 IP 주소가 고쳐지거나 바뀌면 ARP 캐시의 내용과 실제가 달라지기 때문에 ARP 캐시의 값은 주기적으로 삭제되도록 설정되어 있다.



#### ICMP(Internet Control Message Protocol) 프로토콜

IP 프로토콜은 패킷을 목적지에 전달하기 위한 정보만 가지고 있다. 그래서 패킷이 정상적으로 목적지에 도달하면 다행이지만 그렇지 못하면 IP 프로토콜 자체에서는 에러 내용을 처리하는 방법이 없다. 그래서 이런 단점을 보완하고자 나온게 ICMP 프로토콜이다.

ICMP는 목적지가 잘못 설정된 경우 등의 에러 상황이 발생하면 패킷을 송신한 측에게 에러 메세지를 보내주는 프로토콜이다. TCP와 같은 회복 처리는 못 하지만 그래도 에러 메세지를 보내주니 대응이 가능해진다.

우리가 흔히 사용하는 ping 명령어도 ICMP를 이용한 프로그램이라고 한다.

 

#### 이더넷의 기본

이더넷은 데이터를 전달하는 로직이 매우 단순하다. 이더넷에 연결된 특정 장치에서 패킷을 발송하면 이더넷과 연결된 모든 장치에 해당 패킷이 도착한다. 해당 패킷의 수신처 MAC 주소와 일치하는 장치만 해당 패킷을 가져오고 나머지 장치들은 폐기하는 방식으로 통신을 구현한다.

> 원래 이더넷의 원형 : 케이블을 통해 신호가 전체에 흐름 (트렁크 케이블, 트랜시버 케이블, 트렌시버)
> 리피터 허브를 이용한 파생형 : 중앙의 리피터 허브가 신호를 흩뿌림 (리피터 허브, 트위스트 페어 케이블)
> 스위칭 허브를 이용한 형태 : 스위칭 허브는 수신처 MAC 주소에 따라 목적지를 정하고 중계해 원하는 상대에게만 신호가 흐름

이더넷이 어떤 형태로 구현되는지는 몰라도 수신처 MAC 주소, 송신처 MAC 주소, 데이터 타입을 나타내는 이더 타입이 MAC 헤더에 들어간다는 것은 변하지 않는다. (무선 렌도 이더 타입 대신 이터 타입처럼 데이터를 나타내는 구조가 있을 뿐 똑같다.) 이더넷에 접속한 기계는 이더넷이라는 공통된 사양에 따라 동작한다. 



#### 이더넷의 송수신 과정

이더넷 패킷은 디지털 데이터이기 때문에 통신을 위해서는 이를 전기 신호를 바꿔주는 과정이 필요하며 LAN 어댑터가 이 과정을 담당한다. LAN 어댑터의 구조는 제조사에 따라 다르지만 대략적인 구조는 다음과 같다.

<img src="/Users/cuzz/Documents/project-github/cuzzs-log/public/posts/network/image/network02_04.png" alt="network02_04" width="800" height="400"/>

우선 LAN 어댑터는 하드웨어 초기화 과정에서 ROM에 고유한 MAC 주소를 할당받는 작업을 거친다. 네트워크 내에 같은 MAC주소를 가진 기기가 있으면 네트워크가 정상 작동하지 않기 때문에 MAC 주소는 고유해야 하고, 이를 위해 기기를 생성할 때 고유한 MAC 주소를 할당해주는 것이다.

IP 담당 부분에서 만든 이더넷 패킷은 LAN 어댑터에 들어가기 전에 LAN 드라이버를 거치게 된다. 여기서 맨 위에 그림에서 보았듯이 프리엠블과 스타트 프레임 딜리미터가 패킷의 앞에 붙여지고 에러 검출을 위한 FCS(Frame Check Sequence)가 패킷의 뒤에 붙게 된다. 프리엠블은 송신하는 패킷을 읽을 때 타이밍( 클럭 신호 주기 같은 정보 )을 잡기 위한 부분으로 10이 번갈아 나오는 비트열이 56비트로 이어진 형태이다. 스타트 프레임 딜리미터는 프리엠블 뒤에 나오는 데이터로 끝에 11비트를 두어 패킷의 개시 위치를 감지할 수 있게 해준다.

 MAC 회로가 프리엠블의 맨 앞부터 차례대로 전기 신호로 변환하면 해당 신호를 PHY로 보냅니다. 이때 디지털 데이터를 전기 신호로 변환하는 속도가 전송 속도입니다. ( 1메가 비트/초 ) MAC에서는 케이블의 종류나 전송 속도 차이를 무시하고 어느 형식으로 변환할 수 있는 공통 형식으로 전기 신호를 생산해내면 PHY에서는 들어온 전기 신호를 케이블의 종류나 전송 속도에 맞게 다른 전기 신호로 변환한다. 송신 신호를 변환하면서 변환하는 도중 수신 신호가 들어오는지도 확인한다. 반이중 모드에서는 송신 중 수신 신호를 감지하는 기술 또한 중요하다.

리피터 허브의 반이중 모드의 경우 망 내의 서로 다른 기기가 동시에 송신을 하는 상황이 오면 서로의 신호가 섞여 분간할 수 없는 상태가 되는데 이를 충돌이라고 한다. 이렇게 되면 송신을 계속해도 의미가 없으니 송신 동작을 중지하고 충돌이 났다는 것을 알리기 위해 재밍 신호를 보낸다. 해당 신호를 받은 기기는 자신의 MAC 주소 기반으로 하는 난수를 생성하고 여기서 대기 시간을 계산해서 해당 대기 시간만큼 기다린 후 다시 송신을 시작한다. 다시 충돌이 나면 대기 시간을 2배로 늘리고 이 과정을 10번 반복하면 에러라고 판단하고 송신을 중지한다.



#### 이더넷에서 온 신호를 받아들이기 까지

* LAN 어뎁터가 하는 일

  프리엠블과 스타트 프레임 딜리미터로 타이밍 잡기 => 디지털 데이터의 변환 시도 (PHY => MAC) => 버퍼 메모리에 해당 값 저장 => FCS를 이용하여 패킷에 오류가 있는지 확인 => MAC 헤더의 수신처 MAC 주소를 조사하여 자기 것이 맞는지 확인 (아니면 버림)

  참고로 자기 MAC 주소가 아닌 패킷도 전부 수신하는 경우가 있는데 이 동작을 프로미스큐어스 모드(promiscouous mode, 무차별 모드)라고 한다. 이 과정까지 다 하면 LAN 어댑터는 수신이 완료되었다는 통지를 인터럽트라는 구조를 이용해 보낸다. 요즘에는 PnP(Plug and Play : 확장 보드나 주변 기기 등을 자동 설정하는 기능) 덕분에 인터럽트 번호를 걱정할 필요가 없지만 옛날에는 이 번호를 잘못 설정해서 (LAN 어댑터에 11이라는 인터럽트 번호를 설정하면 11번에 대응하도록 LAN 드라이버가 호출되게 등록해야 한다.) LAN 어댑터가 정상 작동하지 않는 문제가 발생하곤 했다.

* LAN 드라이버가 하는 일

  MAC 헤더의 타입 필드 값으로 프로토콜을 판별하여 적절한 프로토콜 스택에 데이터를 전달한다. 요즘에는 TCP/IP가 거의 대세이지만 옛날에는 이 스택 말고도 다양한 스택이 있었다고 한다.

* IP 담당 부분이 하는 일

  IP 헤더를 조사 => 수신처 IP 주소가 자신의 IP 주소(수신한 LAN 어댑터에 할당된 주소)와 맞는지 확인 => 다르면 ICMP라는 프로토콜로 에러 메세지 전송 => 같으면 한 가지 일을 더 하는데 데이터가 커서 여러 패킷으로 나누어져 보내지면 순서에 맞게 원래 모습으로 되돌리는 리어셈블링 과정을 거친다.

* TCP 담당 부분이 하는 일

  수신처의 IP와 PORT, 송신처의 IP와 PORT를 조사하여 해당하는 소켓을 찾는다. 해당하는 소켓을 찾는다면 그 소켓에 통신 진행과정이 적혀있을 테니 거기에 맞게 동작을 수행한다. TCP 담당 부분이 IP 주소도 보는 게 안타깝겠지만 소켓은 통신 전반의 내용을 기록하기 때문에 IP 주소도 저장해야 하며 이를 위해 IP 담당 부분을 따로 호출하기에는 구현이 복잡해지니 유도리있게 TCP 담당 부분이 IP 주소도 참고해서 실리를 챙긴 셈이다.



### UDP 프로토콜을 이용한 송수신 동작

TCP는 효율적으로 패킷의 오류를 검출하고 이를 회복하는 로직을 가지고 있다. 이 덕분에 TCP 기반의 프로그램들은 패킷이 손실될 걱정 없이 프로그램을 짜도 된다. 하지만 TCP는 저 로직 덕분에 동작이 복잡하고 이 때문에 속도가 느리다는 단점이 있다. 그래서 오류를 검출하고 회복하는 로직이 필요 없거나 그 로직을 애플리케이션에서 담당할 수 있다면 굳이 복잡한 TCP를 쓸 이유가 사라진다.

UDP는 수신 확인이나 윈도우와 같은 복잡한 기능이 전혀 없이 포트에 따라서 데이터를 전달하는 기능만 가지고 있는 아주 간단한 Transport layer 프로토콜이다. 헤더에도 송신지 포트 번호, 수신지 포트 정보, 데이터 길이, 체크섬 이외의 정보는 없다. 보통은 전체 데이터가 작아 에러가 나도 그냥 다시 보내면 되는 DNS 리졸버나 음성과 영상처럼 데이터 수신이 일부 실패해도 괜찮은 분야에 많이 쓰인다.

구글에서 만들고 HTTP 3에 편입될 기술인 QUIC의 경우 UDP 기반으로 만들어진 전송 계층 프로토콜이다. UDP에는 단순한 동작만 구현되어 있기 때문에 이걸 기반으로 다른 프로토콜을 만들기 용이하게 해준다.



#### 출처

* ICMP에 대해 참고한 블로그: https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=rbdi3222&logNo=220602423771
* QUIC 참고한 블로그 : https://www.secmem.org/blog/2022/01/03/quic/

