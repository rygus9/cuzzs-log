---
title: 블로그 개편기1, 카테고리와 페이지네이션
tags: ["project"]
uploadDate: 2022년 9월 25일
description: 블로그를 만들면서 다루었던 내용들을 정리해보았습니다.
---

블로그 활동이 생각보다 재밌어서 바쁜 와중에도 틈틈히 글을 쓰다보니 어느새 글이 많아졌다. 그래서 페이지 네비게이션이 없는 페이지로는 더이상 수많은 글들을 감당할 수 없다고 판단하여 페이지 네비게이션을 적용하고자 한다. 또한 맨 처음에는 태그로 만들었는데 확실히 SSG로는 여러 태그를 선택해서 좁히는게 너무 처리하기 힘들다. 대응되는 URL마다 페이지를 만들어내는 방식을 쓰면 태그 갯수의 조합 수 만큼 페이지를 만들어내야 한다. 이게 시간 복잡도가 지수를 달리기 때문에 힘들다. SSG로 틀어야 하나 생각했지만 태그를 그냥 카테고리로 바꾸고 쓰는게 더 괜찮을 꺼라고 생각해서 그냥 내비둔다.



## 1. 카테고리부터 개편을 해보자

현재는 블로그글 상단에 해당 블로그 글의 성격을 나타내는 정보를 표시하는데 여기에 tags필드를 두어 카테고리 정보도 넣었다. 그러나 매번 블로그 글 쓸때마다 태그를 적어서 넣기도 불편하고 오타가 나면 같은 카테고리임을 의도하고 쓴 게 다른 카테고리에 들어가니 좀 그렇다. 그래서 그냥 카테고리 정보를 폴더 명으로 정하고 tags 필드를 제거하기로 하였다.

### 이를 구현해보자

* 생각해보니 옛날에 좀 급하게 끝내느라 파일 정보를 읽는 로직을 너무 보기 힘들게 짰다. 특히 모든 파일을 읽기 위해서 DFS로 짠 로직이 있는데 이제는 폴더 구조가 정해졌으니 굳이 DFS를 필요가 없다고 판단하여 해당 로직을 폴더 구조에 맞는 단순 구현으로 대체하였다.

* 파일 정보를 읽는 로직을 어떤 정보를 읽어오는 지에 따라 파일별로 분류해 두었다. 하지만 코드를 고치다보니 굳이 이렇게 분리할 필요가 있을까 싶어서 하나의 파일에 여러 함수를 export하는 형태로 바꾸었다.
* 코드 전반적으로 tag라는 단어를 없애고 category라는 단어로 교체하였다. 

> 하면서 느낀 점이 함수를 리펙토링할 때에는 테스트가 필요하다는 걸 느꼈다. 지금이야 단순한 로직이니 그냥저냥 했지만 로직이 복잡해지면 테스트 함수 없이 리펙토링하기는 힘들 듯 싶다. 또 한편으로는 현재 기획이 바뀌면서 몇몇 함수의 리턴 값 구조 자체가 바뀌었는데 이렇게 기획이 바뀌어버리면 테스트 코드 자체도 바뀌어야 하기 때문에 테스트도 비용이라는 생각이 들었다.

### 결과

* 파일 정보를 가져오는 로직 전부를 해당 파일 하나에 몰아두었다. 엄청 깔끔하거나 그렇진 않지만 기존보다는 역할도 잘 분리되어 있고 직관적으로 동작한다고 느껴진다. Type 정의와 함수 구현부를 분리할까 했었는데 차피 리펙토링할 때에는 둘 다 고쳐야 하기 때문에 그냥 가까운게 더 낫다고 판단하였다. 로직이 복잡하면 분리하는 게 더 좋지만 그렇지 않다면 비슷한 건 하나로 두는게 좋다고 생각한다.

```ts
import fs from "fs";
import matter from "gray-matter";

const postsRoot = "public/posts";

export interface Category {
  categoryName: string;
}

export const getCategorys = (): Category[] =>
  fs
    .readdirSync(postsRoot, { withFileTypes: true })
    .filter((dir) => !dir.name.startsWith("."))
    .map((dir) => ({ categoryName: dir.name }));

interface PostLocation {
  path: string;
  category: string;
}

export const getPostLocations = () => {
  const posts: PostLocation[] = [];
  const baseCategorys = getCategorys();

  for (const { categoryName } of baseCategorys) {
    const subfiles = fs
      .readdirSync(`${postsRoot}/${categoryName}`, { withFileTypes: true })
      .filter((elem) => !elem.isDirectory() && elem.name.endsWith(".md"))
      .map((postFile) => ({ path: `${postsRoot}/${categoryName}/${postFile.name}`, category: categoryName }));
    posts.push(...subfiles);
  }
  return posts;
};

export interface PostInfo {
  title: string;
  category: string;
  uploadDate: string;
  description: string;
}

export const getPost = (path: string, category: string) => {
  const fileTexts = fs.readFileSync(path, "utf8");
  const { data: postInfo } = matter(fileTexts);
  postInfo["category"] = category;
  return postInfo as PostInfo;
};

export interface PostElem {
  id: number;
  postInfo: PostInfo;
  path: string;
}

export const getPosts = (): PostElem[] =>
  getPostLocations()
    .map((loc) => ({ postInfo: { ...getPost(loc.path, loc.category) }, path: loc.path }))
    .sort((a, b) => (a.postInfo.uploadDate > b.postInfo.uploadDate ? 1 : -1))
    .map((elem, index) => ({ ...elem, id: index }))
    .reverse();

export const getPostContent = (path: string) => {
  const fileTexts = fs.readFileSync(path, "utf-8");
  const { content: postContent } = matter(fileTexts);
  return postContent;
};
```

* VSCode의 검색 기능을 이용해 Tag라는 언어를 코드 상에서 완전히 지웠다. Tag는 이제 없고 모두 다 카테고리로 변경하였다.



## 2. 페이지 네비게이션을 구현해보자

정말 급한 기능 중 하나다. 거의 주에 2~3개씩 적어서 포스트 갯수는 늘어가는데 페이지 네비게이션은 없다. SSG 방식이라 글이 많아질수록 해당 HTML 파일을 그대로 다 가져올텐데 통신 낭비에 속도 낭비라 생각한다. 그렇다고 따로 api를 파서 무한 스크롤로 구현하기에는 페이지네이션 대신 이걸 구현하므로써 얻는 이득 대비 서버를 만들어야 한다는 비용이 더 크다고 판단되어 그냥 페이지 네비게이션 방식을 사용하기로 하였다.
